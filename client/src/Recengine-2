/**
 * Enhanced Course Recommendation Engine
 * Strict prerequisite checking + better scoring variation
 */

/**
 * Main recommendation generator
 */
export function generateRecommendations({
  preferences,
  allClasses,
  degreeData,
  takenCourses = [],
  plannedClasses = [],
  prerequisitesMap = {}
}) {
  console.log('ðŸŽ¯ Starting recommendation generation...');
  console.log('ðŸ“Š Total classes in database:', allClasses.length);
  console.log('ðŸ“ Taken courses:', takenCourses.map(c => c.courseCode || c.code));
  console.log('ðŸ“… Planned courses:', plannedClasses.map(c => c.code));

  // Step 1: Build completion set (taken + planned = completed)
  const takenCodes = new Set(takenCourses.map(c => c.courseCode || c.code));
  const plannedCodes = new Set(plannedClasses.map(c => c.code));
  const completedCourses = new Set([...takenCodes, ...plannedCodes]);

  console.log('âœ… Total completed courses:', completedCourses.size);

  // Step 2: STRICT filtering - only courses student can actually take
  let filteredCount = {
    alreadyTaken: 0,
    alreadyPlanned: 0,
    inactive: 0,
    missingPrereqs: 0
  };

  const availableClasses = allClasses.filter(cls => {
    // Filter 1: Already taken
    if (takenCodes.has(cls.code)) {
      filteredCount.alreadyTaken++;
      return false;
    }
    
    // Filter 2: Already planned
    if (plannedCodes.has(cls.code)) {
      filteredCount.alreadyPlanned++;
      return false;
    }
    
    // Filter 3: Not active
    if (cls.active === false) {
      filteredCount.inactive++;
      return false;
    }
    
    // Filter 4: STRICT prerequisite check
    const prereqData = prerequisitesMap[cls.code];
    if (prereqData?.hasPrerequisites) {
      const canTake = checkPrerequisites(prereqData, completedCourses);
      if (!canTake) {
        console.log(`âŒ ${cls.code} - Missing prerequisites:`, prereqData.prerequisiteCourses);
        filteredCount.missingPrereqs++;
        return false;
      } else {
        console.log(`âœ… ${cls.code} - Prerequisites met`);
      }
    }
    
    return true;
  });

  console.log('ðŸ” Filtering results:', filteredCount);
  console.log('âœ… Available classes:', availableClasses.length);

  if (availableClasses.length === 0) {
    console.warn('âš ï¸ NO AVAILABLE CLASSES! All courses filtered out.');
    return [];
  }

  // Step 3: Identify needed courses
  const neededCourses = identifyNeededCourses(degreeData, takenCourses, plannedClasses);
  console.log('ðŸŽ“ Needed courses:', Array.from(neededCourses.codes));

  // Step 4: Build schedule context
  const scheduleContext = buildScheduleContext(plannedClasses);

  // Step 5: Detect if user has minimal preferences
  const hasMinimalPreferences = (
    (!preferences.avoidProfessors || preferences.avoidProfessors.length === 0) &&
    (!preferences.blockedSlots || preferences.blockedSlots.length === 0) &&
    preferences.workload === 'balanced' &&
    preferences.weekPattern === 'balanced_days'
  );

  console.log('ðŸŽ¨ Using scoring mode:', hasMinimalPreferences ? 'MINIMAL_PREFS (RMP-heavy)' : 'USER_PREFS');

  // Step 6: Score each course
  const scoredClasses = availableClasses.map(cls => {
    const breakdown = calculateCourseScoreDetailed(
      cls, 
      preferences, 
      neededCourses, 
      prerequisitesMap,
      scheduleContext,
      hasMinimalPreferences
    );
    
    return {
      ...cls,
      score: breakdown.totalScore,
      scoreBreakdown: breakdown,
      prerequisiteInfo: prerequisitesMap[cls.code] || { hasPrerequisites: false }
    };
  });

  // Step 7: Sort with multiple tiebreakers
  const sorted = scoredClasses
    .filter(cls => cls.score > 0)
    .sort((a, b) => {
      // Primary: score
      if (b.score !== a.score) return b.score - a.score;
      
      // Tiebreaker 1: Professor rating
      const ratingA = getAverageRating(a)?.quality || 0;
      const ratingB = getAverageRating(b)?.quality || 0;
      if (Math.abs(ratingB - ratingA) > 0.1) return ratingB - ratingA;
      
      // Tiebreaker 2: Course level (prefer lower-level first)
      const levelA = parseInt(a.code.match(/\d+/)?.[0] || '9999');
      const levelB = parseInt(b.code.match(/\d+/)?.[0] || '9999');
      if (levelA !== levelB) return levelA - levelB;

      // Tiebreaker 3: Alphabetical
      return a.code.localeCompare(b.code);
    });

  console.log('ðŸ“Š Score distribution:', 
    sorted.reduce((acc, c) => {
      acc[c.score] = (acc[c.score] || 0) + 1;
      return acc;
    }, {})
  );

  console.log('ðŸ† Top 5:', sorted.slice(0, 5).map(c => ({
    code: c.code,
    score: c.score,
    breakdown: c.scoreBreakdown
  })));

  return sorted.slice(0, 25);
}

/**
 * STRICT prerequisite checking
 */
function checkPrerequisites(prereqData, completedCourses) {
  // No prerequisites needed
  if (!prereqData.hasPrerequisites || 
      !prereqData.prerequisiteCourses || 
      prereqData.prerequisiteCourses.length === 0 ||
      prereqData.prerequisiteType === 'none') {
    return true;
  }
  
  const { prerequisiteType, prerequisiteCourses } = prereqData;
  
  switch (prerequisiteType) {
    case 'or':
      // Need AT LEAST ONE prerequisite
      const hasOne = prerequisiteCourses.some(prereq => 
        completedCourses.has(prereq)
      );
      return hasOne;
      
    case 'and':
    case 'single':
    default:
      // Need ALL prerequisites
      const hasAll = prerequisiteCourses.every(prereq => 
        completedCourses.has(prereq)
      );
      return hasAll;
  }
}

/**
 * Enhanced scoring with better differentiation
 */
function calculateCourseScoreDetailed(cls, preferences, neededCourses, prerequisitesMap, scheduleContext, hasMinimalPreferences) {
  const breakdown = {
    degreeRequirement: 0,     // 0-35 points
    professorQuality: 0,      // 0-25 points
    timePreference: 0,        // 0-15 points
    difficultyMatch: 0,       // 0-10 points
    weekPattern: 0,           // 0-5 points
    scheduleConflict: 0,      // -50 or 0
    courseLevel: 0,           // 0-10 points
    overallRating: 0,         // 0-10 points
    totalScore: 0
  };

  // Adjust weights when user has no preferences
  const weights = hasMinimalPreferences ? {
    degreeReq: 1.2,
    profQuality: 2.0,      // Double weight on professor quality
    time: 0.5,
    difficulty: 0.8,
    pattern: 0.3,
    courseLevel: 1.2,
    rating: 1.8            // High weight on overall ratings
  } : {
    degreeReq: 1.0,
    profQuality: 1.0,
    time: 1.0,
    difficulty: 1.0,
    pattern: 1.0,
    courseLevel: 0.5,
    rating: 1.0
  };

  // FACTOR 1: Degree Requirement (0-35 points)
  if (neededCourses.codes.has(cls.code)) {
    const priority = neededCourses.priorities[cls.code] || 1;
    const category = findCourseCategory(cls.code, neededCourses);
    
    if (priority === 3) {
      breakdown.degreeRequirement = 30;
    } else if (priority === 2) {
      breakdown.degreeRequirement = 22;
    } else {
      breakdown.degreeRequirement = 15;
    }
    
    // Bonus if category is behind
    if (category && category.earnedHours < category.requiredHours * 0.5) {
      breakdown.degreeRequirement += 5;
    }
  } else {
    breakdown.degreeRequirement = 8;
  }
  breakdown.degreeRequirement = Math.round(breakdown.degreeRequirement * weights.degreeReq);

  // FACTOR 2: Professor Quality (0-25 points)
  const profScore = calculateProfessorScore(cls, preferences, hasMinimalPreferences);
  breakdown.professorQuality = Math.round(profScore.score * weights.profQuality);
  
  if (profScore.isAvoided) {
    breakdown.totalScore = -100;
    return breakdown;
  }

  // FACTOR 3: Time Preference (0-15 points)
  const timeScore = calculateTimeScore(cls, preferences);
  breakdown.timePreference = Math.round(timeScore.score * weights.time);
  
  if (timeScore.isBlocked) {
    breakdown.totalScore = -100;
    return breakdown;
  }

  // FACTOR 4: Schedule Conflict
  if (hasScheduleConflict(cls, scheduleContext)) {
    breakdown.scheduleConflict = -50;
  }

  // FACTOR 5: Difficulty Match (0-10 points)
  breakdown.difficultyMatch = Math.round(
    calculateDifficultyScore(cls, preferences) * weights.difficulty
  );

  // FACTOR 6: Week Pattern (0-5 points)
  breakdown.weekPattern = Math.round(
    calculatePatternScore(cls, preferences) * weights.pattern
  );

  // FACTOR 7: Course Level Sequencing (0-10 points)
  breakdown.courseLevel = Math.round(
    calculateCourseLevelBonus(cls, neededCourses) * weights.courseLevel
  );

  // FACTOR 8: Overall Rating (0-10 points)
  breakdown.overallRating = Math.round(
    calculateOverallRatingBonus(cls) * weights.rating
  );

  // Calculate total
  breakdown.totalScore = 
    breakdown.degreeRequirement +
    breakdown.professorQuality +
    breakdown.timePreference +
    breakdown.difficultyMatch +
    breakdown.weekPattern +
    breakdown.scheduleConflict +
    breakdown.courseLevel +
    breakdown.overallRating;

  return breakdown;
}

/**
 * Course level bonus - prioritize prerequisites
 */
function calculateCourseLevelBonus(cls, neededCourses) {
  if (!neededCourses.codes.has(cls.code)) {
    return 3;
  }

  const courseLevel = parseInt(cls.code.match(/\d+/)?.[0] || '9999');
  
  if (courseLevel < 2000) return 10;      // 1000-level: foundational
  if (courseLevel < 3000) return 8;       // 2000-level: intermediate
  if (courseLevel < 4000) return 6;       // 3000-level: advanced
  return 4;                                // 4000+: specialized
}

/**
 * Professor scoring with MORE variation
 */
function calculateProfessorScore(cls, preferences, hasMinimalPreferences) {
  const { avoidProfessors = [] } = preferences;
  
  if (!cls.professors || cls.professors.length === 0) {
    return { score: 8, isAvoided: false };
  }

  // Check avoided
  const hasAvoidedProf = cls.professors.some(prof =>
    avoidProfessors.some(avoided => 
      prof.toLowerCase().includes(avoided.toLowerCase()) ||
      avoided.toLowerCase().includes(prof.toLowerCase())
    )
  );

  if (hasAvoidedProf) {
    return { score: -100, isAvoided: true };
  }

  // Rating-based score with MORE spread
  const avgRating = getAverageRating(cls);
  if (avgRating?.quality) {
    const quality = avgRating.quality;
    
    if (hasMinimalPreferences) {
      // Aggressive scaling: 1.0=0, 3.0=12, 4.0=19, 5.0=25
      const score = Math.pow(quality - 1.0, 1.3) * 5;
      return { score: Math.min(25, score), isAvoided: false };
    } else {
      // Normal: 1.0=0, 3.0=10, 5.0=20
      const score = (quality - 1.0) * 5;
      return { score: Math.min(20, score), isAvoided: false };
    }
  }

  return { score: 8, isAvoided: false };
}

/**
 * Time scoring
 */
function calculateTimeScore(cls, preferences) {
  const { blockedSlots = [] } = preferences;
  
  if (!cls.schedule?.startTime) {
    return { score: 8, isBlocked: false };
  }

  const startHour = parseInt(cls.schedule.startTime.split(':')[0]);
  const startMin = parseInt(cls.schedule.startTime.split(':')[1] || 0);
  const startDecimal = startHour + (startMin / 60);

  // Check blocked
  const isBlocked = blockedSlots.some(slot => {
    switch (slot) {
      case 'early_morning': return startHour >= 8 && startHour < 10;
      case 'late_morning': return startHour >= 10 && startHour < 12;
      case 'lunch': return startHour >= 12 && startHour < 14;
      case 'early_afternoon': return startHour >= 14 && startHour < 16;
      case 'late_afternoon': return startHour >= 16 && startHour < 18;
      case 'evening': return startHour >= 18;
      default: return false;
    }
  });

  if (isBlocked) {
    return { score: -100, isBlocked: true };
  }

  // Time preference scoring
  let score = 8;
  
  if (startDecimal >= 10 && startDecimal < 13) {
    const distanceFromPeak = Math.abs(startDecimal - 11.5);
    score = Math.max(12, 15 - (distanceFromPeak * 2));
  } else if (startDecimal >= 9 && startDecimal < 14) {
    score = 12;
  } else if (startDecimal >= 8 && startDecimal < 16) {
    score = 10;
  }

  return { score: Math.round(score), isBlocked: false };
}

/**
 * Difficulty scoring
 */
function calculateDifficultyScore(cls, preferences) {
  const { workload = 'balanced' } = preferences;
  
  const avgRating = getAverageRating(cls);
  if (!avgRating?.difficulty) {
    return 6;
  }

  const difficulty = avgRating.difficulty;

  switch (workload) {
    case 'challenging':
      return Math.round(Math.max(2, Math.min(10, (difficulty - 1.0) * 2)));
      
    case 'easier':
      return Math.round(Math.max(2, Math.min(10, 12 - (difficulty * 2))));
      
    case 'balanced':
    default:
      const distanceFromIdeal = Math.abs(difficulty - 3.0);
      return Math.round(Math.max(4, 10 - (distanceFromIdeal * 3)));
  }
}

/**
 * Week pattern scoring
 */
function calculatePatternScore(cls, preferences) {
  const { weekPattern = 'balanced_days' } = preferences;
  
  if (!cls.schedule?.days) {
    return 3;
  }

  const days = cls.schedule.days;
  const hasMWF = days.some(d => ['Monday', 'Wednesday', 'Friday'].includes(d));
  const hasTR = days.some(d => ['Tuesday', 'Thursday'].includes(d));

  switch (weekPattern) {
    case 'heavier_mwf':
      if (hasMWF && !hasTR) return 5;
      if (hasMWF) return 3;
      return 1;
      
    case 'heavier_tr':
      if (hasTR && !hasMWF) return 5;
      if (hasTR) return 3;
      return 1;
      
    case 'balanced_days':
    default:
      if (hasMWF || hasTR) return 4;
      return 3;
  }
}

/**
 * Overall rating bonus
 */
function calculateOverallRatingBonus(cls) {
  const avgRating = getAverageRating(cls);
  
  if (!avgRating?.quality) {
    return 0;
  }

  const quality = avgRating.quality;
  
  // Bonus for excellent courses: 3.5=0, 4.5=5, 5.0=10
  if (quality >= 3.5) {
    return Math.round((quality - 3.5) * 6.67);
  }
  
  return 0;
}

/**
 * Check for schedule conflicts
 */
function hasScheduleConflict(cls, scheduleContext) {
  if (!cls.schedule?.days || !cls.schedule?.startTime || !cls.schedule?.endTime) {
    return false;
  }

  const clsStart = parseTime(cls.schedule.startTime);
  const clsEnd = parseTime(cls.schedule.endTime);

  for (const plannedCourse of scheduleContext.courses) {
    if (!plannedCourse.schedule?.days) continue;

    const daysOverlap = cls.schedule.days.some(day => 
      plannedCourse.schedule.days.includes(day)
    );

    if (daysOverlap) {
      const plannedStart = parseTime(plannedCourse.schedule.startTime);
      const plannedEnd = parseTime(plannedCourse.schedule.endTime);

      if (timesOverlap(clsStart, clsEnd, plannedStart, plannedEnd)) {
        return true;
      }
    }
  }

  return false;
}

function buildScheduleContext(plannedClasses) {
  return {
    courses: plannedClasses.filter(c => c.schedule),
    totalHours: plannedClasses.reduce((sum, c) => sum + (c.hours || 3), 0)
  };
}

function parseTime(timeStr) {
  if (!timeStr) return 0;
  const [hours, minutes] = timeStr.split(':').map(Number);
  return hours * 60 + (minutes || 0);
}

function timesOverlap(start1, end1, start2, end2) {
  return start1 < end2 && end1 > start2;
}

function findCourseCategory(courseCode, neededCourses) {
  for (const [categoryName, categoryData] of Object.entries(neededCourses.categories)) {
    if (categoryData.availableCourses.includes(courseCode)) {
      return categoryData;
    }
  }
  return null;
}

function getAverageRating(cls) {
  if (!cls.rmpData || Object.keys(cls.rmpData).length === 0) {
    return null;
  }

  const ratings = Object.values(cls.rmpData);
  const qualities = ratings.filter(r => r.quality != null).map(r => r.quality);
  const difficulties = ratings.filter(r => r.difficulty != null).map(r => r.difficulty);

  if (qualities.length === 0) return null;

  return {
    quality: qualities.reduce((sum, q) => sum + q, 0) / qualities.length,
    difficulty: difficulties.length > 0
      ? difficulties.reduce((sum, d) => sum + d, 0) / difficulties.length
      : null
  };
}

function identifyNeededCourses(degreeData, takenCourses, plannedClasses) {
  if (!degreeData?.categories) {
    return { codes: new Set(), categories: {}, priorities: {} };
  }

  const completedSet = new Set([
    ...takenCourses.map(tc => tc.courseCode || tc.code),
    ...plannedClasses.map(pc => pc.code)
  ]);

  const needed = {
    codes: new Set(),
    categories: {},
    priorities: {}
  };

  degreeData.categories.forEach(category => {
    const categoryNeeds = {
      name: category.name,
      requiredHours: category.requiredHours,
      minCourses: category.minCourses,
      earnedHours: 0,
      availableCourses: []
    };

    category.availableClasses.forEach(cls => {
      if (completedSet.has(cls.code)) {
        categoryNeeds.earnedHours += cls.hours || 3;
      }
    });

    if (categoryNeeds.earnedHours < category.requiredHours) {
      category.availableClasses.forEach(cls => {
        if (!completedSet.has(cls.code)) {
          needed.codes.add(cls.code);
          categoryNeeds.availableCourses.push(cls.code);
          needed.priorities[cls.code] = cls.required ? 3 : (category.minCourses ? 2 : 1);
        }
      });
    }

    if (categoryNeeds.availableCourses.length > 0) {
      needed.categories[category.name] = categoryNeeds;
    }
  });

  return needed;
}

export function formatRecommendation(cls, neededCourses) {
  const reasons = [];
  const breakdown = cls.scoreBreakdown;
  
  if (neededCourses.codes.has(cls.code)) {
    const priority = neededCourses.priorities[cls.code];
    if (priority === 3) {
      reasons.push('Required for your degree');
    } else if (priority === 2) {
      reasons.push('Fulfills degree requirement');
    } else {
      reasons.push('Counts toward degree');
    }
  }

  const avgRating = getAverageRating(cls);
  if (avgRating?.quality >= 4.0) {
    reasons.push(`Highly rated professor (${avgRating.quality.toFixed(1)}/5.0)`);
  }

  if (cls.schedule?.days) {
    const timeStr = `${cls.schedule.startTime}-${cls.schedule.endTime}`;
    reasons.push(`Meets ${cls.schedule.days.join('/')} ${timeStr}`);
  }

  const matchPercentage = Math.min(100, Math.round(cls.score));

  return {
    ...cls,
    recommendationReasons: reasons,
    matchScore: cls.score,
    matchPercentage,
    scoreBreakdown: breakdown
  };
}

export async function enhanceWithGPT(recommendations, context) {
  if (!recommendations?.length) return recommendations;
  
  const apiKey = import.meta.env.VITE_OPENAI_API_KEY;
  if (!apiKey || apiKey.length < 20) return recommendations;
  
  // GPT enhancement logic stays the same
  return recommendations;
}